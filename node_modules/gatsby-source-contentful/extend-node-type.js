"use strict";

var _extends2 = require("babel-runtime/helpers/extends");

var _extends3 = _interopRequireDefault(_extends2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Promise = require(`bluebird`);

var _require = require(`graphql`),
    GraphQLObjectType = _require.GraphQLObjectType,
    GraphQLBoolean = _require.GraphQLBoolean,
    GraphQLString = _require.GraphQLString,
    GraphQLInt = _require.GraphQLInt,
    GraphQLFloat = _require.GraphQLFloat,
    GraphQLEnumType = _require.GraphQLEnumType;

var qs = require(`qs`);
var base64Img = require(`base64-img`);
var _ = require(`lodash`);

var ImageFormatType = new GraphQLEnumType({
  name: `ContentfulImageFormat`,
  values: {
    NO_CHANGE: { value: `` },
    JPG: { value: `jpg` },
    PNG: { value: `png` },
    WEBP: { value: `webp` }
  }
});

var ImageResizingBehavior = new GraphQLEnumType({
  name: `ImageResizingBehavior`,
  values: {
    NO_CHANGE: {
      value: ``
    },
    PAD: {
      value: `pad`,
      description: `Same as the default resizing, but adds padding so that the generated image has the specified dimensions.`
    },

    CROP: {
      value: `crop`,
      description: `Crop a part of the original image to match the specified size.`
    },
    FILL: {
      value: `fill`,
      description: `Crop the image to the specified dimensions, if the original image is smaller than these dimensions, then the image will be upscaled.`
    },
    THUMB: {
      value: `thumb`,
      description: `When used in association with the f parameter below, creates a thumbnail from the image based on a focus area.`
    },
    SCALE: {
      value: `scale`,
      description: `Scale the image regardless of the original aspect ratio.`
    }
  }
});

var ImageCropFocusType = new GraphQLEnumType({
  name: `ContentfulImageCropFocus`,
  values: {
    TOP: { value: `top` },
    TOP_LEFT: { value: `top_left` },
    TOP_RIGHT: { value: `top_right` },
    BOTTOM: { value: `bottom` },
    BOTTOM_RIGHT: { value: `bottom_left` },
    BOTTOM_LEFT: { value: `bottom_right` },
    RIGHT: { value: `right` },
    LEFT: { value: `left` },
    FACES: { value: `faces` }
  }
});

var isImage = function isImage(image) {
  return _.includes([`image/jpeg`, `image/jpg`, `image/png`, `image/webp`, `image/gif`], _.get(image, `file.contentType`));
};

var getBase64Image = function getBase64Image(imageProps) {
  if (!imageProps) return null;

  var requestUrl = `https:${imageProps.baseUrl}?w=20`;
  // TODO add caching.
  return new Promise(function (resolve) {
    base64Img.requestBase64(requestUrl, function (a, b, body) {
      resolve(body);
    });
  });
};

var getBasicImageProps = function getBasicImageProps(image, args) {
  var aspectRatio = void 0;
  if (args.width && args.height) {
    aspectRatio = args.width / args.height;
  } else {
    aspectRatio = image.file.details.image.width / image.file.details.image.height;
  }

  return {
    baseUrl: image.file.url,
    contentType: image.file.contentType,
    aspectRatio,
    width: image.file.details.image.width,
    height: image.file.details.image.height
  };
};

var createUrl = function createUrl(imgUrl) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  // Convert to Contentful names and filter out undefined/null values.
  var args = _.pickBy({
    w: options.width,
    h: options.height,
    fl: options.jpegProgressive ? `progressive` : null,
    q: options.quality,
    fm: options.toFormat ? options.toFormat : ``,
    fit: options.resizingBehavior ? options.resizingBehavior : ``,
    f: options.cropFocus ? options.cropFocus : ``
  }, _.identity);
  return `${imgUrl}?${qs.stringify(args)}`;
};
exports.createUrl = createUrl;

var resolveResponsiveResolution = function resolveResponsiveResolution(image, options) {
  if (!isImage(image)) return null;

  var _getBasicImageProps = getBasicImageProps(image, options),
      baseUrl = _getBasicImageProps.baseUrl,
      width = _getBasicImageProps.width,
      aspectRatio = _getBasicImageProps.aspectRatio;

  var desiredAspectRatio = aspectRatio;

  // If we're cropping, calculate the specified aspect ratio.
  if (options.height) {
    desiredAspectRatio = options.width / options.height;
  }

  // If the user selected a height (so cropping) and fit option
  // is not set, we'll set our defaults
  if (options.height) {
    if (!options.resizingBehavior) {
      options.resizingBehavior = `fill`;
    }
  }

  // Create sizes (in width) for the image. If the width of the
  // image is 800px, the sizes would then be: 800, 1200, 1600,
  // 2400.
  //
  // This is enough sizes to provide close to the optimal image size for every
  // device size / screen resolution
  var sizes = [];
  sizes.push(options.width);
  sizes.push(options.width * 1.5);
  sizes.push(options.width * 2);
  sizes.push(options.width * 3);
  sizes = sizes.map(Math.round);

  // Filter out sizes larger than the image's width.
  var filteredSizes = sizes.filter(function (size) {
    return size < width;
  });

  // Sort sizes for prettiness.
  var sortedSizes = _.sortBy(filteredSizes);

  // Create the srcSet.
  var srcSet = sortedSizes.map(function (size, i) {
    var resolution = void 0;
    switch (i) {
      case 0:
        resolution = `1x`;
        break;
      case 1:
        resolution = `1.5x`;
        break;
      case 2:
        resolution = `2x`;
        break;
      case 3:
        resolution = `3x`;
        break;
      default:
    }
    var h = Math.round(size / desiredAspectRatio);
    return `${createUrl(baseUrl, (0, _extends3.default)({}, options, {
      width: size,
      height: h
    }))} ${resolution}`;
  }).join(`,\n`);

  var pickedHeight = void 0;
  if (options.height) {
    pickedHeight = options.height;
  } else {
    pickedHeight = options.width / desiredAspectRatio;
  }

  return {
    aspectRatio: aspectRatio,
    baseUrl,
    width: Math.round(options.width),
    height: Math.round(pickedHeight),
    src: createUrl(baseUrl, (0, _extends3.default)({}, options, {
      width: options.width
    })),
    srcSet
  };
};
exports.resolveResponsiveResolution = resolveResponsiveResolution;

var resolveResponsiveSizes = function resolveResponsiveSizes(image, options) {
  if (!isImage(image)) return null;

  var _getBasicImageProps2 = getBasicImageProps(image, options),
      baseUrl = _getBasicImageProps2.baseUrl,
      width = _getBasicImageProps2.width,
      aspectRatio = _getBasicImageProps2.aspectRatio;

  var desiredAspectRatio = aspectRatio;

  // If we're cropping, calculate the specified aspect ratio.
  if (options.maxHeight) {
    desiredAspectRatio = options.maxWidth / options.maxHeight;
  }

  // If the users didn't set a default sizes, we'll make one.
  if (!options.sizes) {
    options.sizes = `(max-width: ${options.maxWidth}px) 100vw, ${options.maxWidth}px`;
  }

  // Create sizes (in width) for the image. If the max width of the container
  // for the rendered markdown file is 800px, the sizes would then be: 200,
  // 400, 800, 1200, 1600, 2400.
  //
  // This is enough sizes to provide close to the optimal image size for every
  // device size / screen resolution
  var sizes = [];
  sizes.push(options.maxWidth / 4);
  sizes.push(options.maxWidth / 2);
  sizes.push(options.maxWidth);
  sizes.push(options.maxWidth * 1.5);
  sizes.push(options.maxWidth * 2);
  sizes.push(options.maxWidth * 3);
  sizes = sizes.map(Math.round);

  // Filter out sizes larger than the image's maxWidth.
  var filteredSizes = sizes.filter(function (size) {
    return size < width;
  });

  // Add the original image to ensure the largest image possible
  // is available for small images.
  filteredSizes.push(width);

  // Sort sizes for prettiness.
  var sortedSizes = _.sortBy(filteredSizes);

  // Create the srcSet.
  var srcSet = sortedSizes.map(function (width) {
    var h = Math.round(width / desiredAspectRatio);
    return `${createUrl(image.file.url, (0, _extends3.default)({}, options, {
      width,
      height: h
    }))} ${Math.round(width)}w`;
  }).join(`,\n`);

  return {
    aspectRatio: aspectRatio,
    baseUrl,
    src: createUrl(baseUrl, (0, _extends3.default)({}, options, {
      width: options.maxWidth,
      height: options.maxHeight
    })),
    srcSet,
    sizes: options.sizes
  };
};
exports.resolveResponsiveSizes = resolveResponsiveSizes;

var resolveResize = function resolveResize(image, options) {
  if (!isImage(image)) return null;

  var _getBasicImageProps3 = getBasicImageProps(image, options),
      baseUrl = _getBasicImageProps3.baseUrl,
      aspectRatio = _getBasicImageProps3.aspectRatio;

  // If the user selected a height (so cropping) and fit option
  // is not set, we'll set our defaults


  if (options.height) {
    if (!options.resizingBehavior) {
      options.resizingBehavior = `fill`;
    }
  }

  var pickedWidth = options.width;
  var pickedHeight = void 0;
  if (options.height) {
    pickedHeight = options.height;
  } else {
    pickedHeight = pickedWidth / aspectRatio;
  }
  return {
    src: createUrl(image.file.url, options),
    width: Math.round(pickedWidth),
    height: Math.round(pickedHeight),
    aspectRatio,
    baseUrl
  };
};

exports.resolveResize = resolveResize;

exports.extendNodeType = function (_ref) {
  var type = _ref.type;

  if (type.name !== `ContentfulAsset`) {
    return {};
  }

  return {
    resolutions: {
      type: new GraphQLObjectType({
        name: `ContentfulResolutions`,
        fields: {
          base64: {
            type: GraphQLString,
            resolve(imageProps) {
              return getBase64Image(imageProps);
            }
          },
          aspectRatio: { type: GraphQLFloat },
          width: { type: GraphQLFloat },
          height: { type: GraphQLFloat },
          src: { type: GraphQLString },
          srcSet: { type: GraphQLString },
          srcWebp: {
            type: GraphQLString,
            resolve(_ref2) {
              var image = _ref2.image,
                  options = _ref2.options,
                  context = _ref2.context;

              if (_.get(image, `file.contentType`) === `image/webp` || options.toFormat === `webp`) {
                return null;
              }

              var resolutions = resolveResponsiveResolution(image, (0, _extends3.default)({}, options, {
                toFormat: `webp`
              }));
              return _.get(resolutions, `src`);
            }
          },
          srcSetWebp: {
            type: GraphQLString,
            resolve(_ref3) {
              var image = _ref3.image,
                  options = _ref3.options,
                  context = _ref3.context;

              if (_.get(image, `file.contentType`) === `image/webp` || options.toFormat === `webp`) {
                return null;
              }

              var resolutions = resolveResponsiveResolution(image, (0, _extends3.default)({}, options, {
                toFormat: `webp`
              }));
              return _.get(resolutions, `srcSet`);
            }
          }
        }
      }),
      args: {
        width: {
          type: GraphQLInt,
          defaultValue: 400
        },
        height: {
          type: GraphQLInt
        },
        quality: {
          type: GraphQLInt,
          defaultValue: 50
        },
        toFormat: {
          type: ImageFormatType,
          defaultValue: ``
        },
        resizingBehavior: {
          type: ImageResizingBehavior
        },
        cropFocus: {
          type: ImageCropFocusType,
          defaultValue: null
        }
      },
      resolve: function resolve(image, options, context) {
        return Promise.resolve(resolveResponsiveResolution(image, options)).then(function (node) {
          return (0, _extends3.default)({}, node, {
            image,
            options,
            context
          });
        });
      }
    },
    sizes: {
      type: new GraphQLObjectType({
        name: `ContentfulSizes`,
        fields: {
          base64: {
            type: GraphQLString,
            resolve(imageProps) {
              return getBase64Image(imageProps);
            }
          },
          aspectRatio: { type: GraphQLFloat },
          src: { type: GraphQLString },
          srcSet: { type: GraphQLString },
          srcWebp: {
            type: GraphQLString,
            resolve(_ref4) {
              var image = _ref4.image,
                  options = _ref4.options,
                  context = _ref4.context;

              if (_.get(image, `file.contentType`) === `image/webp` || options.toFormat === `webp`) {
                return null;
              }

              var sizes = resolveResponsiveSizes(image, (0, _extends3.default)({}, options, {
                toFormat: `webp`
              }));
              return _.get(sizes, `src`);
            }
          },
          srcSetWebp: {
            type: GraphQLString,
            resolve(_ref5) {
              var image = _ref5.image,
                  options = _ref5.options,
                  context = _ref5.context;

              if (_.get(image, `file.contentType`) === `image/webp` || options.toFormat === `webp`) {
                return null;
              }

              var sizes = resolveResponsiveSizes(image, (0, _extends3.default)({}, options, {
                toFormat: `webp`
              }));
              return _.get(sizes, `srcSet`);
            }
          },
          sizes: { type: GraphQLString }
        }
      }),
      args: {
        maxWidth: {
          type: GraphQLInt,
          defaultValue: 800
        },
        maxHeight: {
          type: GraphQLInt
        },
        quality: {
          type: GraphQLInt,
          defaultValue: 50
        },
        toFormat: {
          type: ImageFormatType,
          defaultValue: ``
        },
        resizingBehavior: {
          type: ImageResizingBehavior
        },
        cropFocus: {
          type: ImageCropFocusType,
          defaultValue: null
        },
        sizes: {
          type: GraphQLString
        }
      },
      resolve: function resolve(image, options, context) {
        return Promise.resolve(resolveResponsiveSizes(image, options)).then(function (node) {
          return (0, _extends3.default)({}, node, {
            image,
            options,
            context
          });
        });
      }
    },
    responsiveResolution: {
      deprecationReason: `We dropped the "responsive" part of the name to make it shorter https://github.com/gatsbyjs/gatsby/pull/2320/`,
      type: new GraphQLObjectType({
        name: `ContentfulResponsiveResolution`,
        fields: {
          base64: {
            type: GraphQLString,
            resolve(imageProps) {
              return getBase64Image(imageProps);
            }
          },
          aspectRatio: { type: GraphQLFloat },
          width: { type: GraphQLFloat },
          height: { type: GraphQLFloat },
          src: { type: GraphQLString },
          srcSet: { type: GraphQLString }
        }
      }),
      args: {
        width: {
          type: GraphQLInt,
          defaultValue: 400
        },
        height: {
          type: GraphQLInt
        },
        quality: {
          type: GraphQLInt,
          defaultValue: 50
        },
        toFormat: {
          type: ImageFormatType,
          defaultValue: ``
        },
        resizingBehavior: {
          type: ImageResizingBehavior
        },
        cropFocus: {
          type: ImageCropFocusType,
          defaultValue: null
        }
      },
      resolve(image, options, context) {
        return resolveResponsiveResolution(image, options);
      }
    },
    responsiveSizes: {
      deprecationReason: `We dropped the "responsive" part of the name to make it shorter https://github.com/gatsbyjs/gatsby/pull/2320/`,
      type: new GraphQLObjectType({
        name: `ContentfulResponsiveSizes`,
        fields: {
          base64: {
            type: GraphQLString,
            resolve(imageProps) {
              return getBase64Image(imageProps);
            }
          },
          aspectRatio: { type: GraphQLFloat },
          src: { type: GraphQLString },
          srcSet: { type: GraphQLString },
          sizes: { type: GraphQLString }
        }
      }),
      args: {
        maxWidth: {
          type: GraphQLInt,
          defaultValue: 800
        },
        maxHeight: {
          type: GraphQLInt
        },
        quality: {
          type: GraphQLInt,
          defaultValue: 50
        },
        toFormat: {
          type: ImageFormatType,
          defaultValue: ``
        },
        resizingBehavior: {
          type: ImageResizingBehavior
        },
        cropFocus: {
          type: ImageCropFocusType,
          defaultValue: null
        },
        sizes: {
          type: GraphQLString
        }
      },
      resolve(image, options, context) {
        return resolveResponsiveSizes(image, options);
      }
    },
    resize: {
      type: new GraphQLObjectType({
        name: `ContentfulResize`,
        fields: {
          base64: {
            type: GraphQLString,
            resolve(imageProps) {
              return getBase64Image(imageProps);
            }
          },
          src: { type: GraphQLString },
          width: { type: GraphQLInt },
          height: { type: GraphQLInt },
          aspectRatio: { type: GraphQLFloat }
        }
      }),
      args: {
        width: {
          type: GraphQLInt,
          defaultValue: 400
        },
        height: {
          type: GraphQLInt
        },
        quality: {
          type: GraphQLInt,
          defaultValue: 50
        },
        jpegProgressive: {
          type: GraphQLBoolean,
          defaultValue: true
        },
        resizingBehavior: {
          type: ImageResizingBehavior
        },
        toFormat: {
          type: ImageFormatType,
          defaultValue: ``
        },
        cropFocus: {
          type: ImageCropFocusType,
          defaultValue: null
        }
      },
      resolve(image, options, context) {
        return resolveResize(image, options);
      }
    }
  };
};